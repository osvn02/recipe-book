{\rtf1\ansi\deff0\deftab720{\fonttbl{\f0\fmodern Courier New;}}
{\colortbl\red0\green0\blue0;\red255\green255\blue255;\red200\green200\blue200;\red0\green0\blue0;\red152\green152\blue217;\red192\green192\blue192;\red128\green128\blue255;\red170\green170\blue240;\red0\green128\blue128;\red107\green153\blue153;\red128\green0\blue0;\red172\green89\blue89;\red240\green0\blue240;\red240\green200\blue240;\red0\green0\blue160;\red135\green135\blue200;\red0\green160\blue0;\red154\green200\blue154;\red190\green0\blue190;\red190\green137\blue190;\red0\green0\blue255;\red190\green190\blue255;\red224\green160\blue0;\red224\green206\blue159;\red132\green160\blue132;\red255\green0\blue0;\red255\green200\blue200;\red64\green64\blue128;\red133\green133\blue172;\red128\green255\blue255;\red55\green55\blue55;}
{\info{\comment Generated by the Code::Blocks RTF Exporter plugin}
{\title Untitled}}

\deflang1033\pard\plain\f0\fs16 \cb3\cf16 #ifndef DLIST_H_INCLUDED
\par #define DLIST_H_INCLUDED
\par 
\par #include <exception>
\par #include <string>
\par #include <iostream>
\par #include <fstream>
\par 
\par \cb3\cf14\b template \b0\cb3\cf25 <\cb3\cf14\b class \b0\cb1\cf0 T\cb3\cf25 >
\par \cb3\cf14\b class \b0\cb1\cf0 DLList\cb3\cf25 \{
\par \cb3\cf14\b private\b0\cb3\cf25 :
\par     \cb3\cf14\b class \b0\cb1\cf0 Node\cb3\cf25 \{
\par     \cb3\cf14\b private\b0\cb3\cf25 :
\par         \cb1\cf0 T\cb3\cf25 * \cb1\cf0 dataPtr\cb3\cf25 ;
\par         \cb1\cf0 Node\cb3\cf25 * \cb1\cf0 prev\cb3\cf25 ;
\par         \cb1\cf0 Node\cb3\cf25 * \cb1\cf0 next\cb3\cf25 ;
\par 
\par     \cb3\cf14\b public\b0\cb3\cf25 :
\par         \cb3\cf14\b class \b0\cb1\cf0 Exception \cb3\cf25 : \cb3\cf14\b public \b0\cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b exception\b0\cb3\cf25 \{
\par         \cb3\cf14\b private\b0\cb3\cf25 :
\par             \cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b string \b0\cb1\cf0 msg\cb3\cf25 ;
\par 
\par         \cb3\cf14\b public\b0\cb3\cf25 :
\par             \cb3\cf14\b explicit \b0\cb1\cf0 Exception\cb3\cf25 (\cb3\cf14\b const char\b0\cb3\cf25 * \cb1\cf0 message\cb3\cf25 ) : \cb1\cf0 msg\cb3\cf25 (\cb1\cf0 message\cb3\cf25 )\{\}
\par             \cb3\cf14\b explicit \b0\cb1\cf0 Exception\cb3\cf25 (\cb3\cf14\b const \b0\cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b string\b0\cb3\cf25 & \cb1\cf0 message\cb3\cf25 ) : \cb1\cf0 msg\cb3\cf25 (\cb1\cf0 message\cb3\cf25 )\{\}
\par             \cb3\cf14\b virtual \b0\cb3\cf25 ~\cb1\cf0 Exception\cb3\cf25 () \cb3\cf14\b throw\b0\cb3\cf25 ()\{\}
\par             \cb3\cf14\b virtual const char\b0\cb3\cf25 * \cb1\cf0 what\cb3\cf25 () \cb3\cf14\b const throw\b0\cb3\cf25 ()\{
\par             \cb3\cf14\b return \b0\cb1\cf0 msg\cb3\cf25 .\cb1\cf0 c_str\cb3\cf25 ();
\par             \}
\par         \};
\par 
\par         \cb1\cf0 Node\cb3\cf25 ();
\par         \cb1\cf0 Node\cb3\cf25 (\cb3\cf14\b const \b0\cb1\cf0 T\cb3\cf25 &);
\par         ~\cb1\cf0 Node\cb3\cf25 ();
\par 
\par         \cb1\cf0 T\cb3\cf25 * \cb1\cf0 getDataPtr\cb3\cf25 () \cb3\cf14\b const\b0\cb3\cf25 ;
\par         \cb1\cf0 T getData\cb3\cf25 () \cb3\cf14\b const\b0\cb3\cf25 ;
\par         \cb1\cf0 Node\cb3\cf25 * \cb1\cf0 getPrev\cb3\cf25 () \cb3\cf14\b const\b0\cb3\cf25 ;
\par         \cb1\cf0 Node\cb3\cf25 * \cb1\cf0 getNext\cb3\cf25 () \cb3\cf14\b const\b0\cb3\cf25 ;
\par 
\par         \cb3\cf14\b void \b0\cb1\cf0 setDataPtr\cb3\cf25 (\cb1\cf0 T\cb3\cf25 *);
\par         \cb3\cf14\b void \b0\cb1\cf0 setData\cb3\cf25 (\cb3\cf14\b const \b0\cb1\cf0 T\cb3\cf25 &);
\par         \cb3\cf14\b void \b0\cb1\cf0 setPrev\cb3\cf25 (\cb1\cf0 Node\cb3\cf25 *);
\par         \cb3\cf14\b void \b0\cb1\cf0 setNext\cb3\cf25 (\cb1\cf0 Node\cb3\cf25 *);
\par     \};
\par     \cb1\cf0 Node\cb3\cf25 * \cb1\cf0 header\cb3\cf25 ;
\par     \cb3\cf14\b void \b0\cb1\cf0 copyAll\cb3\cf25 (\cb3\cf14\b const \b0\cb1\cf0 DLList\cb3\cf25 <\cb1\cf0 T\cb3\cf25 >&);
\par     \cb3\cf14\b bool \b0\cb1\cf0 isValidPos\cb3\cf25 (\cb1\cf0 Node\cb3\cf25 *) \cb3\cf14\b const\b0\cb3\cf25 ;
\par     \cb3\cf14\b void \b0\cb1\cf0 swapData\cb3\cf25 (\cb1\cf0 T\cb3\cf25 *, \cb1\cf0 T\cb3\cf25 *);
\par     \cb1\cf0 Node\cb3\cf25 * \cb1\cf0 sortingPartition\cb3\cf25 (\cb1\cf0 Node\cb3\cf25 * \cb1\cf0 l\cb3\cf25 , \cb1\cf0 Node\cb3\cf25 * \cb1\cf0 h\cb3\cf25 , \cb3\cf14\b int \b0\cb1\cf0 cmp\cb3\cf25 (\cb3\cf14\b const \b0\cb1\cf0 T\cb3\cf25 &, \cb3\cf14\b const \b0\cb1\cf0 T\cb3\cf25 &));
\par     \cb3\cf14\b void \b0\cb1\cf0 sortList\cb3\cf25 (\cb1\cf0 Node\cb3\cf25 *, \cb1\cf0 Node\cb3\cf25 *, \cb3\cf14\b int \b0\cb1\cf0 cmp\cb3\cf25 (\cb3\cf14\b const \b0\cb1\cf0 T\cb3\cf25 &, \cb3\cf14\b const \b0\cb1\cf0 T\cb3\cf25 &));
\par \cb3\cf14\b public\b0\cb3\cf25 :
\par     \cb3\cf14\b typedef \b0\cb1\cf0 Node\cb3\cf25 * \cb1\cf0 Position\cb3\cf25 ;
\par 
\par     \cb3\cf14\b class \b0\cb1\cf0 Exception \cb3\cf25 : \cb3\cf14\b public \b0\cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b exception\b0\cb3\cf25 \{
\par         \cb3\cf14\b private\b0\cb3\cf25 :
\par             \cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b string \b0\cb1\cf0 msg\cb3\cf25 ;
\par 
\par         \cb3\cf14\b public\b0\cb3\cf25 :
\par             \cb3\cf14\b explicit \b0\cb1\cf0 Exception\cb3\cf25 (\cb3\cf14\b const char\b0\cb3\cf25 * \cb1\cf0 message\cb3\cf25 ) : \cb1\cf0 msg\cb3\cf25 (\cb1\cf0 message\cb3\cf25 )\{\}
\par             \cb3\cf14\b explicit \b0\cb1\cf0 Exception\cb3\cf25 (\cb3\cf14\b const \b0\cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b string\b0\cb3\cf25 & \cb1\cf0 message\cb3\cf25 ) : \cb1\cf0 msg\cb3\cf25 (\cb1\cf0 message\cb3\cf25 )\{\}
\par             \cb3\cf14\b virtual \b0\cb3\cf25 ~\cb1\cf0 Exception\cb3\cf25 () \cb3\cf14\b throw\b0\cb3\cf25 ()\{\}
\par             \cb3\cf14\b virtual const char\b0\cb3\cf25 * \cb1\cf0 what\cb3\cf25 () \cb3\cf14\b const throw\b0\cb3\cf25 ()\{
\par             \cb3\cf14\b return \b0\cb1\cf0 msg\cb3\cf25 .\cb1\cf0 c_str\cb3\cf25 ();
\par             \}
\par         \};
\par 
\par     \cb1\cf0 DLList\cb3\cf25 ();
\par     \cb1\cf0 DLList\cb3\cf25 (\cb3\cf14\b const \b0\cb1\cf0 DLList\cb3\cf25 <\cb1\cf0 T\cb3\cf25 >&);
\par     ~\cb1\cf0 DLList\cb3\cf25 ();
\par 
\par     \cb3\cf14\b void \b0\cb1\cf0 sortList\cb3\cf25 (\cb3\cf14\b int \b0\cb3\cf25 (*\cb1\cf0 cmp\cb3\cf25 )(\cb3\cf14\b const \b0\cb1\cf0 T\cb3\cf25 &, \cb3\cf14\b const \b0\cb1\cf0 T\cb3\cf25 &));
\par 
\par     \cb3\cf14\b bool \b0\cb1\cf0 isEmpty\cb3\cf25 () \cb3\cf14\b const\b0\cb3\cf25 ;
\par 
\par     \cb3\cf14\b void \b0\cb1\cf0 insertData\cb3\cf25 (\cb1\cf0 Node\cb3\cf25 *, \cb3\cf14\b const \b0\cb1\cf0 T\cb3\cf25 &);
\par     \cb3\cf14\b void \b0\cb1\cf0 deleteData\cb3\cf25 (\cb1\cf0 Node\cb3\cf25 *);
\par 
\par     \cb1\cf0 Node\cb3\cf25 * \cb1\cf0 getFirstPos\cb3\cf25 () \cb3\cf14\b const\b0\cb3\cf25 ;
\par     \cb1\cf0 Node\cb3\cf25 * \cb1\cf0 getLastPos\cb3\cf25 () \cb3\cf14\b const\b0\cb3\cf25 ;
\par     \cb1\cf0 Node\cb3\cf25 * \cb1\cf0 getPrevPos\cb3\cf25 (\cb1\cf0 Node\cb3\cf25 *) \cb3\cf14\b const\b0\cb3\cf25 ;
\par     \cb1\cf0 Node\cb3\cf25 * \cb1\cf0 getNextPos\cb3\cf25 (\cb1\cf0 Node\cb3\cf25 *) \cb3\cf14\b const\b0\cb3\cf25 ;
\par 
\par     \cb1\cf0 Node\cb3\cf25 * \cb1\cf0 findData\cb3\cf25 (\cb3\cf14\b const \b0\cb1\cf0 T\cb3\cf25 &, \cb3\cf14\b int \b0\cb1\cf0 cmp\cb3\cf25 (\cb3\cf14\b const \b0\cb1\cf0 T\cb3\cf25 &, \cb3\cf14\b const \b0\cb1\cf0 T\cb3\cf25 &)) \cb3\cf14\b const\b0\cb3\cf25 ;
\par     \cb1\cf0 T\cb3\cf25 * \cb1\cf0 getElement\cb3\cf25 (\cb1\cf0 Node\cb3\cf25 *) \cb3\cf14\b const\b0\cb3\cf25 ;
\par 
\par     \cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b string \b0\cb1\cf0 toString\cb3\cf25 () \cb3\cf14\b const\b0\cb3\cf25 ;
\par     \cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b string \b0\cb1\cf0 categoricToString\cb3\cf25 (\cb3\cf14\b const \b0\cb1\cf0 T\cb3\cf25 &, \cb3\cf14\b int \b0\cb1\cf0 cmp\cb3\cf25 (\cb3\cf14\b const \b0\cb1\cf0 T\cb3\cf25 &, \cb3\cf14\b const \b0\cb1\cf0 T\cb3\cf25 &)) \cb3\cf14\b const\b0\cb3\cf25 ;
\par 
\par     \cb3\cf14\b void \b0\cb1\cf0 nullify\cb3\cf25 ();
\par 
\par     \cb1\cf0 DLList\cb3\cf25 <\cb1\cf0 T\cb3\cf25 >& \cb3\cf14\b operator \b0\cb3\cf25 = (\cb3\cf14\b const \b0\cb1\cf0 DLList\cb3\cf25 <\cb1\cf0 T\cb3\cf25 >&);
\par 
\par     \cb3\cf14\b void \b0\cb1\cf0 readFromDisk\cb3\cf25 (\cb3\cf14\b const \b0\cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b string\b0\cb3\cf25 &);
\par     \cb3\cf14\b void \b0\cb1\cf0 writeToDisk\cb3\cf25 (\cb3\cf14\b const \b0\cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b string\b0\cb3\cf25 &);
\par \};
\par 
\par \cb3\cf4 //Nodo
\par \cb3\cf14\b template \b0\cb3\cf25 <\cb3\cf14\b class \b0\cb1\cf0 T\cb3\cf25 >
\par \cb1\cf0 DLList\cb3\cf25 <\cb1\cf0 T\cb3\cf25 >::\cb1\cf0 Node\cb3\cf25 ::\cb1\cf0 Node\cb3\cf25 () : \cb1\cf0 dataPtr\cb3\cf25 (\cb3\cf14\b nullptr\b0\cb3\cf25 ), \cb1\cf0 prev\cb3\cf25 (\cb3\cf14\b nullptr\b0\cb3\cf25 ), \cb1\cf0 next\cb3\cf25 (\cb3\cf14\b nullptr\b0\cb3\cf25 )\{\}
\par 
\par \cb3\cf14\b template \b0\cb3\cf25 <\cb3\cf14\b class \b0\cb1\cf0 T\cb3\cf25 >
\par \cb1\cf0 DLList\cb3\cf25 <\cb1\cf0 T\cb3\cf25 >::\cb1\cf0 Node\cb3\cf25 ::\cb1\cf0 Node\cb3\cf25 (\cb3\cf14\b const \b0\cb1\cf0 T\cb3\cf25 & \cb1\cf0 e\cb3\cf25 ) : \cb1\cf0 dataPtr\cb3\cf25 (\cb3\cf14\b new \b0\cb1\cf0 T\cb3\cf25 (\cb1\cf0 e\cb3\cf25 )), \cb1\cf0 prev\cb3\cf25 (\cb3\cf14\b nullptr\b0\cb3\cf25 ), \cb1\cf0 next\cb3\cf25 (\cb3\cf14\b nullptr\b0\cb3\cf25 )
\par \{
\par     \cb3\cf14\b if \b0\cb3\cf25 (\cb1\cf0 dataPtr \cb3\cf25 == \cb3\cf14\b nullptr\b0\cb3\cf25 )\{
\par         \cb3\cf14\b throw \b0\cb1\cf0 Exception\cb3\cf25 (\cb3\cf20 "Memoria insuficiente, no se pudo crear nuevo nodo"\cb3\cf25 );
\par     \}
\par \}
\par 
\par \cb3\cf14\b template \b0\cb3\cf25 <\cb3\cf14\b class \b0\cb1\cf0 T\cb3\cf25 >
\par \cb1\cf0 DLList\cb3\cf25 <\cb1\cf0 T\cb3\cf25 >::\cb1\cf0 Node\cb3\cf25 ::~\cb1\cf0 Node\cb3\cf25 ()
\par \{
\par     \cb3\cf14\b delete \b0\cb1\cf0 dataPtr\cb3\cf25 ;
\par \}
\par 
\par \cb3\cf14\b template \b0\cb3\cf25 <\cb3\cf14\b class \b0\cb1\cf0 T\cb3\cf25 >
\par \cb1\cf0 T\cb3\cf25 * \cb1\cf0 DLList\cb3\cf25 <\cb1\cf0 T\cb3\cf25 >::\cb1\cf0 Node\cb3\cf25 ::\cb1\cf0 getDataPtr\cb3\cf25 () \cb3\cf14\b const
\par \b0\cb3\cf25 \{
\par    \cb3\cf14\b return \b0\cb1\cf0 dataPtr\cb3\cf25 ;
\par \}
\par 
\par \cb3\cf14\b template \b0\cb3\cf25 <\cb3\cf14\b class \b0\cb1\cf0 T\cb3\cf25 >
\par \cb1\cf0 T DLList\cb3\cf25 <\cb1\cf0 T\cb3\cf25 >::\cb1\cf0 Node\cb3\cf25 ::\cb1\cf0 getData\cb3\cf25 () \cb3\cf14\b const
\par \b0\cb3\cf25 \{
\par    \cb3\cf14\b if \b0\cb3\cf25 (\cb1\cf0 dataPtr \cb3\cf25 == \cb3\cf14\b nullptr\b0\cb3\cf25 )\{
\par     \cb3\cf14\b throw \b0\cb1\cf0 Exception\cb3\cf25 (\cb3\cf20 "Dato inexistente, getData"\cb3\cf25 );
\par    \}
\par    \cb3\cf14\b return \b0\cb3\cf25 *\cb1\cf0 dataPtr\cb3\cf25 ;
\par \}
\par 
\par \cb3\cf14\b template \b0\cb3\cf25 <\cb3\cf14\b class \b0\cb1\cf0 T\cb3\cf25 >
\par \cb3\cf14\b typename \b0\cb1\cf0 DLList\cb3\cf25 <\cb1\cf0 T\cb3\cf25 >::\cb1\cf0 Node\cb3\cf25 * \cb1\cf0 DLList\cb3\cf25 <\cb1\cf0 T\cb3\cf25 >::\cb1\cf0 Node\cb3\cf25 ::\cb1\cf0 getPrev\cb3\cf25 () \cb3\cf14\b const
\par \b0\cb3\cf25 \{
\par     \cb3\cf14\b return \b0\cb1\cf0 prev\cb3\cf25 ;
\par \}
\par 
\par \cb3\cf14\b template \b0\cb3\cf25 <\cb3\cf14\b class \b0\cb1\cf0 T\cb3\cf25 >
\par \cb3\cf14\b typename \b0\cb1\cf0 DLList\cb3\cf25 <\cb1\cf0 T\cb3\cf25 >::\cb1\cf0 Node\cb3\cf25 * \cb1\cf0 DLList\cb3\cf25 <\cb1\cf0 T\cb3\cf25 >::\cb1\cf0 Node\cb3\cf25 ::\cb1\cf0 getNext\cb3\cf25 () \cb3\cf14\b const
\par \b0\cb3\cf25 \{
\par     \cb3\cf14\b return \b0\cb1\cf0 next\cb3\cf25 ;
\par \}
\par 
\par \cb3\cf14\b template \b0\cb3\cf25 <\cb3\cf14\b class \b0\cb1\cf0 T\cb3\cf25 >
\par \cb3\cf14\b void \b0\cb1\cf0 DLList\cb3\cf25 <\cb1\cf0 T\cb3\cf25 >::\cb1\cf0 Node\cb3\cf25 ::\cb1\cf0 setDataPtr\cb3\cf25 (\cb1\cf0 T\cb3\cf25 * \cb1\cf0 p\cb3\cf25 )
\par \{
\par     \cb1\cf0 dataPtr \cb3\cf25 = \cb1\cf0 p\cb3\cf25 ;
\par \}
\par 
\par \cb3\cf14\b template \b0\cb3\cf25 <\cb3\cf14\b class \b0\cb1\cf0 T\cb3\cf25 >
\par \cb3\cf14\b void \b0\cb1\cf0 DLList\cb3\cf25 <\cb1\cf0 T\cb3\cf25 >::\cb1\cf0 Node\cb3\cf25 ::\cb1\cf0 setData\cb3\cf25 (\cb3\cf14\b const \b0\cb1\cf0 T\cb3\cf25 & \cb1\cf0 e\cb3\cf25 )
\par \{
\par     \cb3\cf14\b if\b0\cb3\cf25 (\cb1\cf0 dataPtr \cb3\cf25 == \cb3\cf14\b nullptr\b0\cb3\cf25 )\{
\par         \cb3\cf14\b if\b0\cb3\cf25 ((\cb1\cf0 dataPtr \cb3\cf25 = \cb3\cf14\b new \b0\cb1\cf0 T\cb3\cf25 (\cb1\cf0 e\cb3\cf25 )) == \cb3\cf14\b nullptr\b0\cb3\cf25 )\{
\par             \cb3\cf14\b throw \b0\cb1\cf0 Exception\cb3\cf25 (\cb3\cf20 "Memoria no disponible, setData"\cb3\cf25 );
\par         \}
\par     \}
\par     \cb3\cf14\b else\b0\cb3\cf25 \{
\par         *\cb1\cf0 dataPtr \cb3\cf25 = \cb1\cf0 e\cb3\cf25 ;
\par     \}
\par \}
\par 
\par \cb3\cf14\b template \b0\cb3\cf25 <\cb3\cf14\b class \b0\cb1\cf0 T\cb3\cf25 >
\par \cb3\cf14\b void \b0\cb1\cf0 DLList\cb3\cf25 <\cb1\cf0 T\cb3\cf25 >::\cb1\cf0 Node\cb3\cf25 ::\cb1\cf0 setPrev\cb3\cf25 (\cb1\cf0 Node\cb3\cf25 * \cb1\cf0 p\cb3\cf25 )
\par \{
\par     \cb1\cf0 prev \cb3\cf25 = \cb1\cf0 p\cb3\cf25 ;
\par \}
\par 
\par \cb3\cf14\b template \b0\cb3\cf25 <\cb3\cf14\b class \b0\cb1\cf0 T\cb3\cf25 >
\par \cb3\cf14\b void \b0\cb1\cf0 DLList\cb3\cf25 <\cb1\cf0 T\cb3\cf25 >::\cb1\cf0 Node\cb3\cf25 ::\cb1\cf0 setNext\cb3\cf25 (\cb1\cf0 Node\cb3\cf25 * \cb1\cf0 p\cb3\cf25 )
\par \{
\par     \cb1\cf0 next \cb3\cf25 = \cb1\cf0 p\cb3\cf25 ;
\par \}
\par 
\par \cb3\cf4 //Lista
\par \cb3\cf14\b template \b0\cb3\cf25 <\cb3\cf14\b class \b0\cb1\cf0 T\cb3\cf25 >
\par \cb3\cf14\b void \b0\cb1\cf0 DLList\cb3\cf25 <\cb1\cf0 T\cb3\cf25 >::\cb1\cf0 copyAll\cb3\cf25 (\cb3\cf14\b const \b0\cb1\cf0 DLList\cb3\cf25 <\cb1\cf0 T\cb3\cf25 >& \cb1\cf0 l\cb3\cf25 )
\par \{
\par     \cb1\cf0 Node\cb3\cf25 * \cb1\cf0 aux\cb3\cf25 (\cb1\cf0 l\cb3\cf25 .\cb1\cf0 header\cb3\cf25 ->\cb1\cf0 getNext\cb3\cf25 ());
\par     \cb1\cf0 Node\cb3\cf25 * \cb1\cf0 newNode\cb3\cf25 ;
\par 
\par     \cb3\cf14\b while\b0\cb3\cf25 (\cb1\cf0 aux \cb3\cf25 != \cb1\cf0 l\cb3\cf25 .\cb1\cf0 header\cb3\cf25 )\{
\par         \cb3\cf14\b try\b0\cb3\cf25 \{
\par             \cb3\cf14\b if\b0\cb3\cf25 ((\cb1\cf0 newNode \cb3\cf25 = \cb3\cf14\b new \b0\cb1\cf0 Node\cb3\cf25 (\cb1\cf0 aux\cb3\cf25 ->\cb1\cf0 getData\cb3\cf25 ())) == \cb3\cf14\b nullptr\b0\cb3\cf25 )\{
\par                 \cb3\cf14\b throw \b0\cb1\cf0 Exception\cb3\cf25 (\cb3\cf20 "Memoria no disponible, no se pudo copiar la lista"\cb3\cf25 );
\par             \}
\par         \} \cb3\cf14\b catch \b0\cb3\cf25 (\cb3\cf14\b typename \b0\cb1\cf0 Node\cb3\cf25 ::\cb1\cf0 Exception ex\cb3\cf25 )\{
\par             \cb3\cf14\b throw \b0\cb1\cf0 Exception\cb3\cf25 (\cb1\cf0 ex\cb3\cf25 .\cb1\cf0 what\cb3\cf25 ());
\par             \}
\par         \cb1\cf0 newNode\cb3\cf25 ->\cb1\cf0 setPrev\cb3\cf25 (\cb1\cf0 header\cb3\cf25 ->\cb1\cf0 getPrev\cb3\cf25 ());
\par         \cb1\cf0 newNode\cb3\cf25 ->\cb1\cf0 setNext\cb3\cf25 (\cb1\cf0 header\cb3\cf25 );
\par 
\par         \cb1\cf0 header\cb3\cf25 ->\cb1\cf0 getPrev\cb3\cf25 ()->\cb1\cf0 setNext\cb3\cf25 (\cb1\cf0 newNode\cb3\cf25 );
\par         \cb1\cf0 header\cb3\cf25 ->\cb1\cf0 setPrev\cb3\cf25 (\cb1\cf0 newNode\cb3\cf25 );
\par 
\par         \cb1\cf0 aux \cb3\cf25 = \cb1\cf0 aux\cb3\cf25 ->\cb1\cf0 getNext\cb3\cf25 ();
\par     \}
\par \}
\par 
\par \cb3\cf14\b template \b0\cb3\cf25 <\cb3\cf14\b class \b0\cb1\cf0 T\cb3\cf25 >
\par \cb3\cf14\b bool \b0\cb1\cf0 DLList\cb3\cf25 <\cb1\cf0 T\cb3\cf25 >::\cb1\cf0 isValidPos\cb3\cf25 (\cb1\cf0 Node\cb3\cf25 * \cb1\cf0 p\cb3\cf25 ) \cb3\cf14\b const
\par \b0\cb3\cf25 \{
\par     \cb1\cf0 Node\cb3\cf25 * \cb1\cf0 aux\cb3\cf25 (\cb1\cf0 header\cb3\cf25 ->\cb1\cf0 getNext\cb3\cf25 ());
\par     \cb3\cf14\b while \b0\cb3\cf25 (\cb1\cf0 aux \cb3\cf25 != \cb1\cf0 header\cb3\cf25 )\{
\par         \cb3\cf14\b if\b0\cb3\cf25 (\cb1\cf0 aux \cb3\cf25 == \cb1\cf0 p\cb3\cf25 )\{
\par             \cb3\cf14\b return true\b0\cb3\cf25 ;
\par         \}
\par         \cb1\cf0 aux \cb3\cf25 = \cb1\cf0 aux\cb3\cf25 ->\cb1\cf0 getNext\cb3\cf25 ();
\par     \}
\par     \cb3\cf14\b return false\b0\cb3\cf25 ;
\par \}
\par 
\par \cb3\cf14\b template \b0\cb3\cf25 <\cb3\cf14\b class \b0\cb1\cf0 T\cb3\cf25 >
\par \cb1\cf0 DLList\cb3\cf25 <\cb1\cf0 T\cb3\cf25 >::\cb1\cf0 DLList\cb3\cf25 () : \cb1\cf0 header\cb3\cf25 (\cb3\cf14\b new \b0\cb1\cf0 Node\cb3\cf25 )
\par \{
\par     \cb3\cf14\b if\b0\cb3\cf25 (\cb1\cf0 header \cb3\cf25 == \cb3\cf14\b nullptr\b0\cb3\cf25 )\{
\par         \cb3\cf14\b throw \b0\cb1\cf0 Exception\cb3\cf25 (\cb3\cf20 "Memoria no disponible, no se pudo inicializar la lista"\cb3\cf25 );
\par     \}
\par     \cb1\cf0 header\cb3\cf25 ->\cb1\cf0 setPrev\cb3\cf25 (\cb1\cf0 header\cb3\cf25 );
\par     \cb1\cf0 header\cb3\cf25 ->\cb1\cf0 setNext\cb3\cf25 (\cb1\cf0 header\cb3\cf25 );
\par \}
\par 
\par \cb3\cf14\b template \b0\cb3\cf25 <\cb3\cf14\b class \b0\cb1\cf0 T\cb3\cf25 >
\par \cb1\cf0 DLList\cb3\cf25 <\cb1\cf0 T\cb3\cf25 >::\cb1\cf0 DLList\cb3\cf25 (\cb3\cf14\b const \b0\cb1\cf0 DLList\cb3\cf25 <\cb1\cf0 T\cb3\cf25 >& \cb1\cf0 l\cb3\cf25 ) : \cb1\cf0 DLList\cb3\cf25 ()
\par \{
\par     \cb1\cf0 copyAll\cb3\cf25 (\cb1\cf0 l\cb3\cf25 );
\par \}
\par 
\par \cb3\cf14\b template \b0\cb3\cf25 <\cb3\cf14\b class \b0\cb1\cf0 T\cb3\cf25 >
\par \cb1\cf0 DLList\cb3\cf25 <\cb1\cf0 T\cb3\cf25 >::~\cb1\cf0 DLList\cb3\cf25 ()
\par \{
\par     \cb1\cf0 nullify\cb3\cf25 ();
\par     \cb3\cf14\b delete \b0\cb1\cf0 header\cb3\cf25 ;
\par \}
\par 
\par \cb3\cf14\b template \b0\cb3\cf25 <\cb3\cf14\b class \b0\cb1\cf0 T\cb3\cf25 >
\par \cb3\cf14\b bool \b0\cb1\cf0 DLList\cb3\cf25 <\cb1\cf0 T\cb3\cf25 >::\cb1\cf0 isEmpty\cb3\cf25 () \cb3\cf14\b const
\par \b0\cb3\cf25 \{
\par     \cb3\cf14\b return \b0\cb1\cf0 header\cb3\cf25 ->\cb1\cf0 getNext\cb3\cf25 () == \cb1\cf0 header\cb3\cf25 ;
\par \}
\par 
\par \cb3\cf14\b template \b0\cb3\cf25 <\cb3\cf14\b class \b0\cb1\cf0 T\cb3\cf25 >
\par \cb3\cf14\b void \b0\cb1\cf0 DLList\cb3\cf25 <\cb1\cf0 T\cb3\cf25 >::\cb1\cf0 insertData\cb3\cf25 (\cb1\cf0 Node\cb3\cf25 * \cb1\cf0 p\cb3\cf25 , \cb3\cf14\b const \b0\cb1\cf0 T\cb3\cf25 & \cb1\cf0 e\cb3\cf25 )
\par \{
\par     \cb3\cf14\b if \b0\cb3\cf25 (\cb1\cf0 p \cb3\cf25 != \cb3\cf14\b nullptr \b0\cb1\cf0 and \cb3\cf25 !\cb1\cf0 isValidPos\cb3\cf25 (\cb1\cf0 p\cb3\cf25 ))\{
\par         \cb3\cf14\b throw \b0\cb1\cf0 Exception\cb3\cf25 (\cb3\cf20 "Posicion invalida, no se pudo insertar el dato"\cb3\cf25 );
\par     \}
\par 
\par     \cb1\cf0 Node\cb3\cf25 * \cb1\cf0 aux\cb3\cf25 ;
\par     \cb3\cf14\b try\b0\cb3\cf25 \{
\par         \cb1\cf0 aux \cb3\cf25 = \cb3\cf14\b new \b0\cb1\cf0 Node\cb3\cf25 (\cb1\cf0 e\cb3\cf25 );
\par         \}
\par         \cb3\cf14\b catch \b0\cb3\cf25 (\cb3\cf14\b typename \b0\cb1\cf0 Node\cb3\cf25 ::\cb1\cf0 Exception ex\cb3\cf25 )\{
\par             \cb3\cf14\b throw \b0\cb1\cf0 Exception\cb3\cf25 (\cb1\cf0 ex\cb3\cf25 .\cb1\cf0 what\cb3\cf25 ());
\par         \}
\par 
\par     \cb3\cf14\b if \b0\cb3\cf25 (\cb1\cf0 aux \cb3\cf25 == \cb3\cf14\b nullptr\b0\cb3\cf25 )\{
\par         \cb3\cf14\b throw \b0\cb1\cf0 Exception\cb3\cf25 (\cb3\cf20 "Memoria no disponible, no se pudo insertar el dato"\cb3\cf25 );
\par     \}
\par 
\par     \cb3\cf14\b if\b0\cb3\cf25 (\cb1\cf0 p \cb3\cf25 == \cb3\cf14\b nullptr\b0\cb3\cf25 )\{
\par         \cb1\cf0 p \cb3\cf25 = \cb1\cf0 header\cb3\cf25 ;
\par     \}
\par 
\par     \cb1\cf0 aux\cb3\cf25 ->\cb1\cf0 setPrev\cb3\cf25 (\cb1\cf0 p\cb3\cf25 );
\par     \cb1\cf0 aux\cb3\cf25 ->\cb1\cf0 setNext\cb3\cf25 (\cb1\cf0 p\cb3\cf25 ->\cb1\cf0 getNext\cb3\cf25 ());
\par     \cb1\cf0 p\cb3\cf25 ->\cb1\cf0 getNext\cb3\cf25 ()->\cb1\cf0 setPrev\cb3\cf25 (\cb1\cf0 aux\cb3\cf25 );
\par     \cb1\cf0 p\cb3\cf25 ->\cb1\cf0 setNext\cb3\cf25 (\cb1\cf0 aux\cb3\cf25 );
\par \}
\par 
\par \cb3\cf14\b template \b0\cb3\cf25 <\cb3\cf14\b class \b0\cb1\cf0 T\cb3\cf25 >
\par \cb3\cf14\b void \b0\cb1\cf0 DLList\cb3\cf25 <\cb1\cf0 T\cb3\cf25 >::\cb1\cf0 deleteData\cb3\cf25 (\cb1\cf0 Node\cb3\cf25 * \cb1\cf0 p\cb3\cf25 )
\par \{
\par     \cb3\cf14\b if\b0\cb3\cf25 (!\cb1\cf0 isValidPos\cb3\cf25 (\cb1\cf0 p\cb3\cf25 ))\{
\par         \cb3\cf14\b throw \b0\cb1\cf0 Exception\cb3\cf25 (\cb3\cf20 "Posicion invalida, no se pudo borrar el dato"\cb3\cf25 );
\par     \}
\par 
\par     \cb1\cf0 p\cb3\cf25 ->\cb1\cf0 getPrev\cb3\cf25 ()->\cb1\cf0 setNext\cb3\cf25 (\cb1\cf0 p\cb3\cf25 ->\cb1\cf0 getNext\cb3\cf25 ());
\par     \cb1\cf0 p\cb3\cf25 ->\cb1\cf0 getNext\cb3\cf25 ()->\cb1\cf0 setPrev\cb3\cf25 (\cb1\cf0 p\cb3\cf25 ->\cb1\cf0 getPrev\cb3\cf25 ());
\par     \cb3\cf14\b delete \b0\cb1\cf0 p\cb3\cf25 ;
\par \}
\par 
\par \cb3\cf14\b template \b0\cb3\cf25 <\cb3\cf14\b class \b0\cb1\cf0 T\cb3\cf25 >
\par \cb3\cf14\b typename \b0\cb1\cf0 DLList\cb3\cf25 <\cb1\cf0 T\cb3\cf25 >::\cb1\cf0 Node\cb3\cf25 * \cb1\cf0 DLList\cb3\cf25 <\cb1\cf0 T\cb3\cf25 >::\cb1\cf0 getFirstPos\cb3\cf25 () \cb3\cf14\b const
\par \b0\cb3\cf25 \{
\par     \cb3\cf14\b if\b0\cb3\cf25 (\cb1\cf0 isEmpty\cb3\cf25 ())\{
\par         \cb3\cf14\b return nullptr\b0\cb3\cf25 ;
\par     \}
\par 
\par     \cb3\cf14\b return \b0\cb1\cf0 header\cb3\cf25 ->\cb1\cf0 getNext\cb3\cf25 ();
\par \}
\par 
\par \cb3\cf14\b template \b0\cb3\cf25 <\cb3\cf14\b class \b0\cb1\cf0 T\cb3\cf25 >
\par \cb3\cf14\b typename \b0\cb1\cf0 DLList\cb3\cf25 <\cb1\cf0 T\cb3\cf25 >::\cb1\cf0 Node\cb3\cf25 * \cb1\cf0 DLList\cb3\cf25 <\cb1\cf0 T\cb3\cf25 >::\cb1\cf0 getLastPos\cb3\cf25 () \cb3\cf14\b const
\par \b0\cb3\cf25 \{
\par     \cb3\cf14\b if\b0\cb3\cf25 (\cb1\cf0 isEmpty\cb3\cf25 ())\{
\par         \cb3\cf14\b return nullptr\b0\cb3\cf25 ;
\par     \}
\par 
\par     \cb3\cf14\b return \b0\cb1\cf0 header\cb3\cf25 ->\cb1\cf0 getPrev\cb3\cf25 ();
\par \}
\par 
\par \cb3\cf14\b template \b0\cb3\cf25 <\cb3\cf14\b class \b0\cb1\cf0 T\cb3\cf25 >
\par \cb3\cf14\b typename \b0\cb1\cf0 DLList\cb3\cf25 <\cb1\cf0 T\cb3\cf25 >::\cb1\cf0 Node\cb3\cf25 * \cb1\cf0 DLList\cb3\cf25 <\cb1\cf0 T\cb3\cf25 >::\cb1\cf0 getPrevPos\cb3\cf25 (\cb1\cf0 Node\cb3\cf25 * \cb1\cf0 p\cb3\cf25 ) \cb3\cf14\b const
\par \b0\cb3\cf25 \{
\par     \cb3\cf14\b if\b0\cb3\cf25 (!\cb1\cf0 isValidPos\cb3\cf25 (\cb1\cf0 p\cb3\cf25 ) \cb1\cf0 or p\cb3\cf25 ==\cb1\cf0 header\cb3\cf25 ->\cb1\cf0 getNext\cb3\cf25 ())\{
\par         \cb3\cf14\b return nullptr\b0\cb3\cf25 ;
\par     \}
\par     \cb3\cf14\b return \b0\cb1\cf0 p\cb3\cf25 ->\cb1\cf0 getPrev\cb3\cf25 ();
\par \}
\par 
\par \cb3\cf14\b template \b0\cb3\cf25 <\cb3\cf14\b class \b0\cb1\cf0 T\cb3\cf25 >
\par \cb3\cf14\b typename \b0\cb1\cf0 DLList\cb3\cf25 <\cb1\cf0 T\cb3\cf25 >::\cb1\cf0 Node\cb3\cf25 * \cb1\cf0 DLList\cb3\cf25 <\cb1\cf0 T\cb3\cf25 >::\cb1\cf0 getNextPos\cb3\cf25 (\cb1\cf0 Node\cb3\cf25 * \cb1\cf0 p\cb3\cf25 ) \cb3\cf14\b const
\par \b0\cb3\cf25 \{
\par     \cb3\cf14\b if\b0\cb3\cf25 (!\cb1\cf0 isValidPos\cb3\cf25 (\cb1\cf0 p\cb3\cf25 ) \cb1\cf0 or p\cb3\cf25 ==\cb1\cf0 header\cb3\cf25 ->\cb1\cf0 getPrev\cb3\cf25 ())\{
\par         \cb3\cf14\b return nullptr\b0\cb3\cf25 ;
\par     \}
\par     \cb3\cf14\b return \b0\cb1\cf0 p\cb3\cf25 ->\cb1\cf0 getNext\cb3\cf25 ();
\par \}
\par 
\par \cb3\cf14\b template \b0\cb3\cf25 <\cb3\cf14\b class \b0\cb1\cf0 T\cb3\cf25 >
\par \cb3\cf14\b typename \b0\cb1\cf0 DLList\cb3\cf25 <\cb1\cf0 T\cb3\cf25 >::\cb1\cf0 Node\cb3\cf25 * \cb1\cf0 DLList\cb3\cf25 <\cb1\cf0 T\cb3\cf25 >::\cb1\cf0 findData\cb3\cf25 (\cb3\cf14\b const \b0\cb1\cf0 T\cb3\cf25 & \cb1\cf0 e\cb3\cf25 , \cb3\cf14\b int \b0\cb1\cf0 cmp\cb3\cf25 (\cb3\cf14\b const \b0\cb1\cf0 T\cb3\cf25 &, \cb3\cf14\b const \b0\cb1\cf0 T\cb3\cf25 &)) \cb3\cf14\b const
\par \b0\cb3\cf25 \{
\par     \cb1\cf0 Node\cb3\cf25 * \cb1\cf0 aux\cb3\cf25 (\cb1\cf0 header\cb3\cf25 ->\cb1\cf0 getNext\cb3\cf25 ());
\par     \cb3\cf14\b while\b0\cb3\cf25 (\cb1\cf0 aux \cb3\cf25 != \cb1\cf0 header\cb3\cf25 )\{
\par         \cb3\cf14\b if\b0\cb3\cf25 (\cb1\cf0 cmp\cb3\cf25 (\cb1\cf0 aux\cb3\cf25 ->\cb1\cf0 getData\cb3\cf25 (), \cb1\cf0 e\cb3\cf25 ) == \cb3\cf12 0\cb3\cf25 )\{
\par             \cb3\cf14\b return \b0\cb1\cf0 aux\cb3\cf25 ;
\par         \}
\par         \cb1\cf0 aux \cb3\cf25 = \cb1\cf0 aux\cb3\cf25 ->\cb1\cf0 getNext\cb3\cf25 ();
\par     \}
\par     \cb3\cf14\b return nullptr\b0\cb3\cf25 ;
\par \}
\par 
\par \cb3\cf14\b template \b0\cb3\cf25 <\cb3\cf14\b class \b0\cb1\cf0 T\cb3\cf25 >
\par \cb1\cf0 T\cb3\cf25 * \cb1\cf0 DLList\cb3\cf25 <\cb1\cf0 T\cb3\cf25 >::\cb1\cf0 getElement\cb3\cf25 (\cb1\cf0 Node\cb3\cf25 * \cb1\cf0 p\cb3\cf25 ) \cb3\cf14\b const
\par \b0\cb3\cf25 \{
\par     \cb3\cf14\b if\b0\cb3\cf25 (!\cb1\cf0 isValidPos\cb3\cf25 (\cb1\cf0 p\cb3\cf25 ))\{
\par         \cb3\cf14\b throw \b0\cb1\cf0 Exception\cb3\cf25 (\cb3\cf20 "Posicion invalida, no se pudo recuperar el elemento"\cb3\cf25 );
\par     \}
\par 
\par     \cb3\cf14\b return \b0\cb1\cf0 p\cb3\cf25 ->\cb1\cf0 getDataPtr\cb3\cf25 ();
\par \}
\par 
\par \cb3\cf14\b template \b0\cb3\cf25 <\cb3\cf14\b class \b0\cb1\cf0 T\cb3\cf25 >
\par \cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b string \b0\cb1\cf0 DLList\cb3\cf25 <\cb1\cf0 T\cb3\cf25 >::\cb1\cf0 toString\cb3\cf25 () \cb3\cf14\b const
\par \b0\cb3\cf25 \{
\par     \cb1\cf0 Node\cb3\cf25 * \cb1\cf0 aux\cb3\cf25 (\cb1\cf0 header\cb3\cf25 ->\cb1\cf0 getNext\cb3\cf25 ());
\par     \cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b string \b0\cb1\cf0 result\cb3\cf25 ;
\par 
\par     \cb3\cf14\b while\b0\cb3\cf25 (\cb1\cf0 aux \cb3\cf25 != \cb1\cf0 header\cb3\cf25 )\{
\par         \cb1\cf0 result \cb3\cf25 += \cb1\cf0 aux\cb3\cf25 ->\cb1\cf0 getData\cb3\cf25 ().\cb1\cf0 toString\cb3\cf25 () + \cb3\cf20 "\\n"\cb3\cf25 ;
\par         \cb1\cf0 aux \cb3\cf25 = \cb1\cf0 aux\cb3\cf25 ->\cb1\cf0 getNext\cb3\cf25 ();
\par     \}
\par     \cb3\cf14\b return \b0\cb1\cf0 result\cb3\cf25 ;
\par \}
\par 
\par \cb3\cf14\b template \b0\cb3\cf25 <\cb3\cf14\b class \b0\cb1\cf0 T\cb3\cf25 >
\par \cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b string \b0\cb1\cf0 DLList\cb3\cf25 <\cb1\cf0 T\cb3\cf25 >::\cb1\cf0 categoricToString\cb3\cf25 (\cb3\cf14\b const \b0\cb1\cf0 T\cb3\cf25 & \cb1\cf0 e\cb3\cf25 , \cb3\cf14\b int \b0\cb1\cf0 cmp\cb3\cf25 (\cb3\cf14\b const \b0\cb1\cf0 T\cb3\cf25 &, \cb3\cf14\b const \b0\cb1\cf0 T\cb3\cf25 &)) \cb3\cf14\b const
\par \b0\cb3\cf25 \{
\par     \cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b string \b0\cb1\cf0 result\cb3\cf25 ;
\par     \cb1\cf0 Node\cb3\cf25 * \cb1\cf0 aux\cb3\cf25 (\cb1\cf0 header\cb3\cf25 ->\cb1\cf0 getNext\cb3\cf25 ());
\par     \cb3\cf14\b while\b0\cb3\cf25 (\cb1\cf0 aux \cb3\cf25 != \cb1\cf0 header\cb3\cf25 )\{
\par         \cb3\cf14\b if\b0\cb3\cf25 (\cb1\cf0 cmp\cb3\cf25 (\cb1\cf0 e\cb3\cf25 , \cb1\cf0 aux\cb3\cf25 ->\cb1\cf0 getData\cb3\cf25 ()) == \cb3\cf12 0\cb3\cf25 )\{
\par             \cb1\cf0 result \cb3\cf25 += \cb1\cf0 aux\cb3\cf25 ->\cb1\cf0 getData\cb3\cf25 ().\cb1\cf0 toString\cb3\cf25 () + \cb3\cf20 "\\n"\cb3\cf25 ;
\par         \}
\par         \cb1\cf0 aux \cb3\cf25 = \cb1\cf0 aux\cb3\cf25 ->\cb1\cf0 getNext\cb3\cf25 ();
\par     \}
\par     \cb3\cf14\b return \b0\cb1\cf0 result\cb3\cf25 ;
\par \}
\par 
\par \cb3\cf14\b template \b0\cb3\cf25 <\cb3\cf14\b class \b0\cb1\cf0 T\cb3\cf25 >
\par \cb3\cf14\b void \b0\cb1\cf0 DLList\cb3\cf25 <\cb1\cf0 T\cb3\cf25 >::\cb1\cf0 nullify\cb3\cf25 ()
\par \{
\par     \cb1\cf0 Node\cb3\cf25 * \cb1\cf0 aux\cb3\cf25 ;
\par 
\par     \cb3\cf14\b while\b0\cb3\cf25 (\cb1\cf0 header\cb3\cf25 ->\cb1\cf0 getNext\cb3\cf25 () != \cb1\cf0 header\cb3\cf25 )\{
\par         \cb1\cf0 aux \cb3\cf25 = \cb1\cf0 header\cb3\cf25 ->\cb1\cf0 getNext\cb3\cf25 ();
\par 
\par         \cb1\cf0 header\cb3\cf25 ->\cb1\cf0 setNext\cb3\cf25 (\cb1\cf0 aux\cb3\cf25 ->\cb1\cf0 getNext\cb3\cf25 ());
\par 
\par         \cb3\cf14\b delete \b0\cb1\cf0 aux\cb3\cf25 ;
\par     \}
\par     \cb1\cf0 header\cb3\cf25 ->\cb1\cf0 setPrev\cb3\cf25 (\cb1\cf0 header\cb3\cf25 );
\par \}
\par 
\par \cb3\cf14\b template \b0\cb3\cf25 <\cb3\cf14\b class \b0\cb1\cf0 T\cb3\cf25 >
\par \cb1\cf0 DLList\cb3\cf25 <\cb1\cf0 T\cb3\cf25 >& \cb1\cf0 DLList\cb3\cf25 <\cb1\cf0 T\cb3\cf25 >::\cb3\cf14\b operator\b0\cb3\cf25 =(\cb3\cf14\b const \b0\cb1\cf0 DLList\cb3\cf25 <\cb1\cf0 T\cb3\cf25 >& \cb1\cf0 l\cb3\cf25 )
\par \{
\par     \cb1\cf0 nullify\cb3\cf25 ();
\par     \cb1\cf0 copyAll\cb3\cf25 (\cb1\cf0 l\cb3\cf25 );
\par     \cb3\cf14\b return \b0\cb3\cf25 *\cb3\cf14\b this\b0\cb3\cf25 ;
\par \}
\par 
\par \cb3\cf14\b template \b0\cb3\cf25 <\cb3\cf14\b class \b0\cb1\cf0 T\cb3\cf25 >
\par \cb3\cf14\b void \b0\cb1\cf0 DLList\cb3\cf25 <\cb1\cf0 T\cb3\cf25 >::\cb1\cf0 swapData\cb3\cf25 (\cb1\cf0 T\cb3\cf25 * \cb1\cf0 a\cb3\cf25 , \cb1\cf0 T\cb3\cf25 * \cb1\cf0 b\cb3\cf25 )
\par \{
\par     \cb1\cf0 T aux \cb3\cf25 = *\cb1\cf0 a\cb3\cf25 ;
\par     *\cb1\cf0 a \cb3\cf25 = *\cb1\cf0 b\cb3\cf25 ;
\par     *\cb1\cf0 b \cb3\cf25 = \cb1\cf0 aux\cb3\cf25 ;
\par \}
\par 
\par \cb3\cf14\b template \b0\cb3\cf25 <\cb3\cf14\b class \b0\cb1\cf0 T\cb3\cf25 >
\par \cb3\cf14\b typename \b0\cb1\cf0 DLList\cb3\cf25 <\cb1\cf0 T\cb3\cf25 >::\cb1\cf0 Node\cb3\cf25 * \cb1\cf0 DLList\cb3\cf25 <\cb1\cf0 T\cb3\cf25 >::\cb1\cf0 sortingPartition\cb3\cf25 (\cb1\cf0 Node\cb3\cf25 * \cb1\cf0 l\cb3\cf25 , \cb1\cf0 Node\cb3\cf25 * \cb1\cf0 h\cb3\cf25 , \cb3\cf14\b int \b0\cb1\cf0 cmp\cb3\cf25 (\cb3\cf14\b const \b0\cb1\cf0 T\cb3\cf25 &, \cb3\cf14\b const \b0\cb1\cf0 T\cb3\cf25 &))
\par \{
\par     \cb1\cf0 T x \cb3\cf25 = \cb1\cf0 h\cb3\cf25 ->\cb1\cf0 getData\cb3\cf25 ();
\par     \cb1\cf0 Node\cb3\cf25 * \cb1\cf0 i \cb3\cf25 = \cb1\cf0 l\cb3\cf25 ->\cb1\cf0 getPrev\cb3\cf25 ();
\par 
\par     \cb3\cf14\b for\b0\cb3\cf25 (\cb1\cf0 Node\cb3\cf25 * \cb1\cf0 j\cb3\cf25 =\cb1\cf0 l\cb3\cf25 ; \cb1\cf0 j\cb3\cf25 !=\cb1\cf0 h\cb3\cf25 ; \cb1\cf0 j\cb3\cf25 =\cb1\cf0 j\cb3\cf25 ->\cb1\cf0 getNext\cb3\cf25 ())\{
\par         \cb3\cf14\b if\b0\cb3\cf25 (\cb1\cf0 cmp\cb3\cf25 (\cb1\cf0 j\cb3\cf25 ->\cb1\cf0 getData\cb3\cf25 (), \cb1\cf0 x\cb3\cf25 ) <= \cb3\cf12 0\cb3\cf25 )\{
\par             \cb1\cf0 i \cb3\cf25 = (\cb1\cf0 i \cb3\cf25 == \cb1\cf0 header\cb3\cf25 )? \cb1\cf0 l \cb3\cf25 : \cb1\cf0 i\cb3\cf25 ->\cb1\cf0 getNext\cb3\cf25 ();
\par             \cb1\cf0 swapData\cb3\cf25 (\cb1\cf0 i\cb3\cf25 ->\cb1\cf0 getDataPtr\cb3\cf25 (), \cb1\cf0 j\cb3\cf25 ->\cb1\cf0 getDataPtr\cb3\cf25 ());
\par         \}
\par     \}
\par 
\par     \cb1\cf0 i \cb3\cf25 = (\cb1\cf0 i\cb3\cf25 ==\cb1\cf0 header\cb3\cf25 )? \cb1\cf0 l \cb3\cf25 : \cb1\cf0 i\cb3\cf25 ->\cb1\cf0 getNext\cb3\cf25 ();
\par     \cb1\cf0 swapData\cb3\cf25 (\cb1\cf0 i\cb3\cf25 ->\cb1\cf0 getDataPtr\cb3\cf25 (), \cb1\cf0 h\cb3\cf25 ->\cb1\cf0 getDataPtr\cb3\cf25 ());
\par     \cb3\cf14\b return \b0\cb1\cf0 i\cb3\cf25 ;
\par \}
\par 
\par \cb3\cf14\b template \b0\cb3\cf25 <\cb3\cf14\b class \b0\cb1\cf0 T\cb3\cf25 >
\par \cb3\cf14\b void \b0\cb1\cf0 DLList\cb3\cf25 <\cb1\cf0 T\cb3\cf25 >::\cb1\cf0 sortList\cb3\cf25 (\cb3\cf14\b int \b0\cb3\cf25 (*\cb1\cf0 cmp\cb3\cf25 )(\cb3\cf14\b const \b0\cb1\cf0 T\cb3\cf25 &, \cb3\cf14\b const \b0\cb1\cf0 T\cb3\cf25 &))
\par \{
\par      \cb1\cf0 Node\cb3\cf25 * \cb1\cf0 h \cb3\cf25 = \cb1\cf0 getLastPos\cb3\cf25 ();
\par      \cb1\cf0 Node\cb3\cf25 * \cb1\cf0 first \cb3\cf25 = \cb1\cf0 getFirstPos\cb3\cf25 ();
\par      \cb1\cf0 sortList\cb3\cf25 (\cb1\cf0 first\cb3\cf25 , \cb1\cf0 h\cb3\cf25 , \cb1\cf0 cmp\cb3\cf25 );
\par \}
\par 
\par \cb3\cf14\b template \b0\cb3\cf25 <\cb3\cf14\b class \b0\cb1\cf0 T\cb3\cf25 >
\par \cb3\cf14\b void \b0\cb1\cf0 DLList\cb3\cf25 <\cb1\cf0 T\cb3\cf25 >::\cb1\cf0 sortList\cb3\cf25 (\cb1\cf0 Node\cb3\cf25 * \cb1\cf0 l\cb3\cf25 , \cb1\cf0 Node\cb3\cf25 * \cb1\cf0 h\cb3\cf25 , \cb3\cf14\b int \b0\cb1\cf0 cmp\cb3\cf25 (\cb3\cf14\b const \b0\cb1\cf0 T\cb3\cf25 &, \cb3\cf14\b const \b0\cb1\cf0 T\cb3\cf25 &))
\par \{
\par     \cb3\cf14\b if\b0\cb3\cf25 (\cb1\cf0 h\cb3\cf25 !=\cb1\cf0 header and l\cb3\cf25 !=\cb1\cf0 h and l\cb3\cf25 !=\cb1\cf0 h\cb3\cf25 ->\cb1\cf0 getNext\cb3\cf25 ())\{
\par         \cb1\cf0 Node\cb3\cf25 * \cb1\cf0 p \cb3\cf25 = \cb1\cf0 sortingPartition\cb3\cf25 (\cb1\cf0 l\cb3\cf25 , \cb1\cf0 h\cb3\cf25 , \cb1\cf0 cmp\cb3\cf25 );
\par         \cb1\cf0 sortList\cb3\cf25 (\cb1\cf0 l\cb3\cf25 , \cb1\cf0 p\cb3\cf25 ->\cb1\cf0 getPrev\cb3\cf25 (), \cb1\cf0 cmp\cb3\cf25 );
\par         \cb1\cf0 sortList\cb3\cf25 (\cb1\cf0 p\cb3\cf25 ->\cb1\cf0 getNext\cb3\cf25 (), \cb1\cf0 h\cb3\cf25 , \cb1\cf0 cmp\cb3\cf25 );
\par     \}
\par \}
\par 
\par \cb3\cf14\b template \b0\cb3\cf25 <\cb3\cf14\b class \b0\cb1\cf0 T\cb3\cf25 >
\par \cb3\cf14\b void \b0\cb1\cf0 DLList\cb3\cf25 <\cb1\cf0 T\cb3\cf25 >::\cb1\cf0 readFromDisk\cb3\cf25 (\cb3\cf14\b const \b0\cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b string\b0\cb3\cf25 & \cb1\cf0 fileName\cb3\cf25 )
\par \{
\par     \cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b ifstream \b0\cb1\cf0 myFile\cb3\cf25 ;
\par 
\par     \cb1\cf0 myFile\cb3\cf25 .\cb1\cf0 open\cb3\cf25 (\cb1\cf0 fileName\cb3\cf25 );
\par 
\par     \cb3\cf14\b if\b0\cb3\cf25 (!\cb1\cf0 myFile\cb3\cf25 .\cb1\cf0 is_open\cb3\cf25 ())\{
\par         \cb3\cf14\b throw \b0\cb1\cf0 Exception\cb3\cf25 (\cb3\cf20 "No se pudo abrir el archivo para lectura"\cb3\cf25 );
\par     \}
\par 
\par     \cb1\cf0 nullify\cb3\cf25 ();
\par 
\par     \cb1\cf0 T myData\cb3\cf25 ;
\par 
\par     \cb3\cf14\b try\b0\cb3\cf25 \{
\par         \cb3\cf14\b while\b0\cb3\cf25 (\cb1\cf0 myFile \cb3\cf25 >> \cb1\cf0 myData\cb3\cf25 )\{
\par             \cb1\cf0 insertData\cb3\cf25 (\cb1\cf0 getLastPos\cb3\cf25 (), \cb1\cf0 myData\cb3\cf25 );
\par         \}
\par     \}
\par     \cb3\cf14\b catch\b0\cb3\cf25 (\cb1\cf0 Exception ex\cb3\cf25 )\{
\par         \cb1\cf0 myFile\cb3\cf25 .\cb1\cf0 close\cb3\cf25 ();
\par         \cb3\cf14\b throw \b0\cb1\cf0 Exception\cb3\cf25 (\cb1\cf0 ex\cb3\cf25 .\cb1\cf0 what\cb3\cf25 ());
\par     \}
\par     \cb1\cf0 myFile\cb3\cf25 .\cb1\cf0 close\cb3\cf25 ();
\par \}
\par 
\par \cb3\cf14\b template \b0\cb3\cf25 <\cb3\cf14\b class \b0\cb1\cf0 T\cb3\cf25 >
\par \cb3\cf14\b void \b0\cb1\cf0 DLList\cb3\cf25 <\cb1\cf0 T\cb3\cf25 >::\cb1\cf0 writeToDisk\cb3\cf25 (\cb3\cf14\b const \b0\cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b string\b0\cb3\cf25 & \cb1\cf0 fileName\cb3\cf25 )
\par \{
\par     \cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b ofstream \b0\cb1\cf0 myFile\cb3\cf25 ;
\par 
\par     \cb1\cf0 myFile\cb3\cf25 .\cb1\cf0 open\cb3\cf25 (\cb1\cf0 fileName\cb3\cf25 , \cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b ios_base\b0\cb3\cf25 ::\cb1\cf0 trunc\cb3\cf25 );
\par 
\par     \cb3\cf14\b if\b0\cb3\cf25 (!\cb1\cf0 myFile\cb3\cf25 .\cb1\cf0 is_open\cb3\cf25 ())\{
\par         \cb3\cf14\b throw \b0\cb1\cf0 Exception\cb3\cf25 (\cb3\cf20 "No se pudo abrir el archivo para escritura"\cb3\cf25 );
\par     \}
\par 
\par     \cb1\cf0 Node\cb3\cf25 * \cb1\cf0 aux \cb3\cf25 = \cb1\cf0 header\cb3\cf25 ->\cb1\cf0 getNext\cb3\cf25 ();
\par     \cb1\cf0 T data\cb3\cf25 ;
\par     \cb3\cf14\b while\b0\cb3\cf25 (\cb1\cf0 aux \cb3\cf25 != \cb1\cf0 header\cb3\cf25 )\{
\par         \cb1\cf0 data \cb3\cf25 = \cb1\cf0 aux\cb3\cf25 ->\cb1\cf0 getData\cb3\cf25 ();
\par         \cb1\cf0 myFile \cb3\cf25 << \cb1\cf0 data \cb3\cf25 << \cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b endl\b0\cb3\cf25 ;
\par         \cb1\cf0 aux \cb3\cf25 = \cb1\cf0 aux\cb3\cf25 ->\cb1\cf0 getNext\cb3\cf25 ();
\par     \}
\par 
\par     \cb1\cf0 myFile\cb3\cf25 .\cb1\cf0 close\cb3\cf25 ();
\par \}
\par 
\par \cb3\cf16 #endif \cb3\cf4 // DLIST_H_INCLUDED
\par }